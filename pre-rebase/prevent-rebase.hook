
# Python 3: Prevents topic branches already merged to 'next' from being rebased.
import sys
import subprocess

def main():
	publish = "next"
	basebranch = sys.argv[1] if len(sys.argv) > 1 else None
	if len(sys.argv) == 2:
		topic = f"refs/heads/{sys.argv[2]}"
	else:
		try:
			topic = subprocess.check_output(["git", "symbolic-ref", "HEAD"], text=True).strip()
		except Exception:
			sys.exit(0)  # do not interrupt rebasing detached HEAD
	# Only check for topic branches (refs/heads/??/*)
	import re
	if not re.match(r"refs/heads/..+/", topic):
		sys.exit(0)
	# Check if already merged to publish branch
	try:
		merged = subprocess.run(["git", "branch", f"--contains={topic}", publish], capture_output=True, text=True)
		if merged.returncode == 0 and publish in merged.stdout:
			print(f"[prevent-rebase] Refusing to rebase already published branch {topic}", file=sys.stderr)
			sys.exit(1)
	except Exception as e:
		print(f"[prevent-rebase] Error: {e}", file=sys.stderr)
		sys.exit(1)
	sys.exit(0)

if __name__ == "__main__":
	# ...existing Python logic...
if __name__ == "__main__":
	main()
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
