def main():
    import subprocess
    import sys
    import os
    import re

    if len(sys.argv) < 2:
        sys.exit(0)
    commit_msg_file = sys.argv[1]
    # Skip for merges or explicit amend contexts; still run for normal commits (including -m "...")
    if len(sys.argv) > 2 and sys.argv[2] in ("merge", "commit"):
        sys.exit(0)

    # Get staged files
    files = subprocess.run(["git", "diff", "--cached", "--name-only"], capture_output=True, text=True)
    if files.returncode != 0:
        sys.exit(0)
    file_list = [f for f in files.stdout.splitlines() if f.strip()]
    if not file_list:
        sys.exit(0)

    # Analyze file types and names
    only_docs = all(f.endswith(".md") or f.startswith("docs/") for f in file_list)
    only_tests = all(f.startswith("tests/") or ".test." in f or ".spec." in f for f in file_list)
    has_feat = any(
        f.startswith("src/") or f.startswith("feature/") or f.startswith("features/") or f.endswith(".py")
        for f in file_list
    )
    has_fix = any("fix" in f.lower() or "bug" in f.lower() or f.startswith("patch/") for f in file_list)

    # If not clear from file names, check diff content for 'fix' or 'bug'
    if not has_fix:
        diff = subprocess.run(["git", "diff", "--cached"], capture_output=True, text=True)
        if re.search(r"fix|bug", diff.stdout, re.IGNORECASE):
            has_fix = True

    # Use the first staged filename as the scope (without path)
    scope = os.path.basename(file_list[0]) if file_list else "misc"

    if only_docs:
        cc_prefix = f"docs({scope}): "
    elif only_tests:
        cc_prefix = f"test({scope}): "
    elif has_fix:
        cc_prefix = f"fix({scope}): "
    elif has_feat:
        cc_prefix = f"feat({scope}): "
    else:
        cc_prefix = f"chore({scope}): "

    # Conventional types for quick detection
    types = r"feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert"
    cc_re = re.compile(rf"^(?P<type>{types})(\([^\)]+\))?: ", re.IGNORECASE)
    jira_re = re.compile(r"^(?P<jira>[A-Z]+-[0-9]+: )")

    # Load commit message lines
    try:
        with open(commit_msg_file, "r+", encoding="utf-8") as f:
            content = f.read()
            lines = content.splitlines()

            # Find first non-empty, non-comment line index
            idx = None
            for i, line in enumerate(lines):
                if line.strip() == "" or line.lstrip().startswith("#"):
                    continue
                idx = i
                break

            if idx is None:
                # Empty message template; just start it with our prefix
                new_first = cc_prefix
                lines = [new_first]
            else:
                first = lines[idx]

                # If it already has a conventional header (possibly after JIRA), don't duplicate
                first_check = first
                m_jira = jira_re.match(first)
                if m_jira:
                    first_check = first[m_jira.end():]
                if not cc_re.match(first_check):
                    # Insert prefix; keep JIRA at the very start if present
                    if m_jira:
                        lines[idx] = m_jira.group("jira") + cc_prefix + first_check
                    else:
                        lines[idx] = cc_prefix + first
                # else: leave as-is

            # Write back
            f.seek(0)
            f.write("\n".join(lines) + ("\n" if content.endswith("\n") else ""))
            f.truncate()

        # Also print a hint so users see it in the console/editor
        print("\033[1;33m[commit] Applied Conventional Commit prefix\033[0m:")
        print(f"  {cc_prefix}<your message>")
    except Exception:
        # Best-effort; don't block commit on errors here
        pass

    sys.exit(0)

if __name__ == "__main__":
    main()